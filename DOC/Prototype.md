# Prototype
상속 관점에서 자바스크립트는 객체만이 유일한 생성체이다. 각각의 객체는 [[Prototype]]이라는 은닉 속성을 가지는데 자신의 프로토타입이 되는 다른 객체를 가르킨다. 극 객체의 프로토타입 또한 프로토타입을 가지고 있고 이것이 반복되다, 결국 null을 프로토타입으로 가지는 오브젝트에서 끝난다. null은 더 이상의 프로토타입이 없다고 정의되며, 프로토타입 체인의 종점 역할을 한다.

## 상속

자바스크립트 객체는 속성을 저장하는 동적인 "가방"과 (자기만의 속성) 프로토타입 객체에 대한 링크를 가진다. 객체의 어떤 속성에 접근하려할 때 그 객체 자체 속성 뿐만 아니라 객체의 프로토타입, 그 포로토타입의 프로토타입 등 프로토타입 체인의 종단에 이를 때까지 그 속성을 탐색한다.

    // o라는 객체가 있고, 속성 'a' 와 'b'를 갖고 있다고 하자.
    // {a: 1, b: 2}
    // o.[[Prototype]]은 속성 'b'와 'c'를 가지고 있다.
    // {b: 3, c: 4}
    // 마지막으로 o.[[Prototype]].[[Prototype]]은 null이다.
    // null은 프로토타입의 종단을 말하며 정의에 의해서 추가 [[Prototype]]은 없다.
    // {a: 1, b: 2} ---> {b: 3, c: 4} ---> null

    console.log(o.a); // 1
    // o는 'a'라는 속성을 가지는가? 그렇다. 속성의 값은 1이다.

    console.log(o.b); // 2
    // o는 'b'라는 속성을 가지는가? 그렇다. 속성의 값은 2이다.
    // 프로토타입 역시 'b'라는 속성을 가지지만 이 값은 쓰이지 않는다. 이것을 "속성의 가려짐(property shadowing)" 이라고 부른다.

    console.log(o.c); // 4
    // o는 'c'라는 속성을 가지는가? 아니다. 프로토타입을 확인해보자.
    // o.[[Prototype]]은 'c'라는 속성을 가지는가? 가지고 값은 4이다.

    console.log(o.d); // undefined
    // o는 'd'라는 속성을 가지는가? 아니다. 프로토타입을 확인해보자.
    // o.[[Prototype]]은 'd'라는 속성을 가지는가? 아니다. 다시 프로토타입을 확인해보자.
    // o.[[Prototype]].[[Prototype]]은 null이다. 찾는 것을 그만두자.
    // 속성이 발견되지 않았기 때문에 undefined를 반환한다.

## 메소드 상속
자바스크립트에 "메소드" 라는건 없다. 하지만 자바스크립트는 객체의 속성으로 함수를 지정할 수 있고 속성 값을 사용하듯 쓸 수 있다. 속성 값으로 지정한 함수의 상속 역시 위에서 본 속성의 상속과 동일하다. (property shadowing대신, method overriding이라는 용어를 사용한다.)

상속된 함수가 실행 될 때, this라는 변수는 상속된 오브젝트를 가르킨다. 그 함수가 프로토타입의 속성으로 지정되었다고 해도 말이다.

## 프로토타입 체인
* 객체: 자신 ----> Object.prototype ----> null
* 배열: 자신 ----> Array.prototype ----> Object.prototype ----> null
* 함수: 자신 ----> Function.prototype ----> Object.prototype ----> null

자바스크립트의 모든건 객체였다...

!빌트인 타입을 확장하지 말자


## 상속의 방법

### 위임형 상속
new 키워드를 통해 상속 받는다. 상속받은 객체를 변경하면 같은 프로토타입을 공유하는 모든 객체의 상태가 변경되므로 좋은 방법이 아님

### 연결형 상속
객체를 모두 복사한다. Object.assign() 클로저와 함께라면 가장 좋은 방법이다.

### 함수형 상속
나중에 알아보자
